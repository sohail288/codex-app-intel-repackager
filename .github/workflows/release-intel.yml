name: Release Intel Codex App

on:
  workflow_dispatch:
    inputs:
      debug:
        description: "Enable verbose debug logging for upstream metadata fetch/parsing"
        required: false
        default: false
        type: boolean
      force:
        description: "Build and publish even if the upstream version tag already exists"
        required: false
        default: false
        type: boolean
      keep_releases:
        description: "Number of versioned releases to keep during cleanup"
        required: false
        default: "10"
        type: string
      cleanup:
        description: "Delete old versioned releases after publishing"
        required: false
        default: true
        type: boolean
  schedule:
    - cron: "27 */6 * * *"

permissions:
  contents: write

concurrency:
  group: release-intel-codex
  cancel-in-progress: false

jobs:
  check-upstream:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.decide.outputs.should_build }}
      dmg_url: ${{ steps.meta.outputs.dmg_url }}
      short_version: ${{ steps.meta.outputs.short_version }}
      build_version: ${{ steps.meta.outputs.build_version }}
      tag_name: ${{ steps.meta.outputs.tag_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Fetch upstream metadata
        id: meta
        env:
          CHECK_UPSTREAM_LOG_LEVEL: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.debug == 'true' && 'DEBUG' || 'WARNING' }}
        run: |
          set -euo pipefail
          if [[ "${CHECK_UPSTREAM_LOG_LEVEL}" == "DEBUG" ]]; then
            echo "Debug mode enabled for upstream metadata fetch (CHECK_UPSTREAM_LOG_LEVEL=${CHECK_UPSTREAM_LOG_LEVEL})"
          fi
          raw="$(python3 scripts/check_upstream.py)"
          echo "$raw" > upstream.json
          echo "dmg_url=$(python3 -c 'import json;print(json.load(open("upstream.json"))["dmg_url"])')" >> "$GITHUB_OUTPUT"
          echo "short_version=$(python3 -c 'import json;print(json.load(open("upstream.json"))["short_version"])')" >> "$GITHUB_OUTPUT"
          echo "build_version=$(python3 -c 'import json;print(json.load(open("upstream.json"))["build_version"])')" >> "$GITHUB_OUTPUT"
          echo "tag_name=$(python3 -c 'import json;print(json.load(open("upstream.json"))["tag_name"])')" >> "$GITHUB_OUTPUT"
          cat upstream.json

      - name: Decide whether to build
        id: decide
        uses: actions/github-script@v7
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag_name }}
          FORCE_BUILD: ${{ github.event.inputs.force == 'true' && 'true' || 'false' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = process.env.TAG_NAME;
            const force = process.env.FORCE_BUILD === "true";
            if (force) {
              core.info(`Force build requested for ${tag}`);
              core.setOutput("should_build", "true");
              return;
            }
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag,
              });
              core.info(`Release ${tag} already exists; skipping build.`);
              core.setOutput("should_build", "false");
            } catch (err) {
              if (err.status === 404) {
                core.info(`Release ${tag} does not exist; building.`);
                core.setOutput("should_build", "true");
                return;
              }
              throw err;
            }

  build-and-release:
    runs-on: macos-latest
    needs: check-upstream
    if: needs.check-upstream.outputs.should_build == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install Codex CLI and x64 binary package
        run: npm install -g @openai/codex@latest

      - name: Resolve x64 codex binary path
        run: |
          set -euo pipefail
          ROOT="$(npm root -g)"
          CANDIDATE="$(find "$ROOT" -type f -path '*/x86_64-apple-darwin/codex/codex' | head -n 1 || true)"
          if [[ -z "$CANDIDATE" || ! -x "$CANDIDATE" ]]; then
            echo "x64 codex binary not found under npm root: $ROOT" >&2
            find "$ROOT" -maxdepth 6 -type f -name codex | sed -n '1,80p' >&2 || true
            exit 1
          fi
          echo "CODEX_X64_BINARY=$CANDIDATE" >> "$GITHUB_ENV"
          file "$CANDIDATE"

      - name: Download upstream package
        run: |
          set -euo pipefail
          PKG_URL="${{ needs.check-upstream.outputs.dmg_url }}"
          PKG_FILE="Codex.pkg"
          curl -fL --retry 3 --retry-delay 2 "$PKG_URL" -o "$PKG_FILE"
          echo "PKG_URL=$PKG_URL" >> "$GITHUB_ENV"
          echo "PKG_FILE=$PKG_FILE" >> "$GITHUB_ENV"

      - name: Extract Codex.app from package
        run: |
          set -euo pipefail
          rm -rf Codex.app extracted_pkg
          mkdir -p extracted_pkg

          if [[ "$PKG_URL" == *.zip ]]; then
            unzip -q "$PKG_FILE" -d extracted_pkg
            APP_PATH="$(find extracted_pkg -maxdepth 6 -type d -name 'Codex.app' | head -n 1)"
            if [[ -z "$APP_PATH" ]]; then
              echo "Codex.app not found in ZIP package" >&2
              exit 1
            fi
          else
            MNT="$(mktemp -d)/mnt"
            mkdir -p "$MNT"
            hdiutil attach "$PKG_FILE" -nobrowse -readonly -mountpoint "$MNT"
            APP_PATH="$(find "$MNT" -maxdepth 3 -type d -name 'Codex.app' | head -n 1)"
            if [[ -z "$APP_PATH" ]]; then
              echo "Codex.app not found in mounted DMG" >&2
              exit 1
            fi
          fi

          rm -rf Codex.app
          ditto "$APP_PATH" Codex.app
          if [[ "${MNT:-}" != "" ]]; then
            hdiutil detach "$MNT"
          fi

      - name: Repackage Intel app
        run: ./scripts/repackage-intel.sh Codex.app Codex-intel.app

      - name: Package artifacts
        run: |
          set -euo pipefail
          ditto -c -k --sequesterRsrc --keepParent Codex-intel.app "Codex-intel-${{ needs.check-upstream.outputs.short_version }}-${{ needs.check-upstream.outputs.build_version }}.zip"
          shasum -a 256 "Codex-intel-${{ needs.check-upstream.outputs.short_version }}-${{ needs.check-upstream.outputs.build_version }}.zip" > "Codex-intel-${{ needs.check-upstream.outputs.short_version }}-${{ needs.check-upstream.outputs.build_version }}.sha256"

      - name: Publish release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.check-upstream.outputs.tag_name }}
          name: Codex Intel ${{ needs.check-upstream.outputs.short_version }} (${{ needs.check-upstream.outputs.build_version }})
          body: |
            Automated Intel repack for upstream Codex Desktop.

            - Upstream DMG: `${{ needs.check-upstream.outputs.dmg_url }}`
            - Upstream version: `${{ needs.check-upstream.outputs.short_version }}`
            - Upstream build: `${{ needs.check-upstream.outputs.build_version }}`
          files: |
            Codex-intel-${{ needs.check-upstream.outputs.short_version }}-${{ needs.check-upstream.outputs.build_version }}.zip
            Codex-intel-${{ needs.check-upstream.outputs.short_version }}-${{ needs.check-upstream.outputs.build_version }}.sha256
          fail_on_unmatched_files: true

      - name: Move latest tag
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -f codex-intel-latest
          git push origin refs/tags/codex-intel-latest --force

      - name: Publish latest release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: codex-intel-latest
          name: Codex Intel Latest
          body: |
            Moving release pointer for the newest successful Intel repack.

            - Source tag: `${{ needs.check-upstream.outputs.tag_name }}`
            - Upstream version: `${{ needs.check-upstream.outputs.short_version }}`
            - Upstream build: `${{ needs.check-upstream.outputs.build_version }}`
          files: |
            Codex-intel-${{ needs.check-upstream.outputs.short_version }}-${{ needs.check-upstream.outputs.build_version }}.zip
            Codex-intel-${{ needs.check-upstream.outputs.short_version }}-${{ needs.check-upstream.outputs.build_version }}.sha256
          fail_on_unmatched_files: true

      - name: Cleanup old versioned releases
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.cleanup == 'true'
        uses: actions/github-script@v7
        env:
          KEEP_RELEASES: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.keep_releases || '10' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const keep = Number(process.env.KEEP_RELEASES || "10");
            const prefix = "codex-intel-v";
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const all = await github.paginate(github.rest.repos.listReleases, {
              owner,
              repo,
              per_page: 100,
            });

            const versioned = all
              .filter(r => r.tag_name && r.tag_name.startsWith(prefix) && !r.draft)
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            const stale = versioned.slice(keep);
            core.info(`Keeping ${Math.min(keep, versioned.length)} releases, deleting ${stale.length}.`);

            for (const r of stale) {
              core.info(`Deleting release ${r.tag_name} (#${r.id})`);
              await github.rest.repos.deleteRelease({
                owner,
                repo,
                release_id: r.id,
              });
              try {
                await github.rest.git.deleteRef({
                  owner,
                  repo,
                  ref: `tags/${r.tag_name}`,
                });
              } catch (err) {
                core.warning(`Failed to delete tag ${r.tag_name}: ${err.message}`);
              }
            }
